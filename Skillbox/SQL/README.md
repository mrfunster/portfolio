# Цель практической работы
Научиться писать довольно сложные SQL-запросы для доступа к данным. 

Этот навык — один из основных в работе с данными и в равной степени необходим всем: и аналитикам, и моделистам, и data-инженерам.


# Что нужно сделать
В работе семь задач. Решение каждой — это один запрос. 

Прочитайте условие задачи, напишите запрос, обязательно исполните его через утилиту Adminer, как мы делали в материале. 
Убедитесь, что запрос выполняется, то есть не содержит синтаксических ошибок. 
Проверьте, что вывод запроса соответствует условию поставленной задачи. 
Скопируйте текст запроса и сохраните его в обычный текстовый файл, указав номер задачи. 
В результате выполнения всех семи задач у вас должен получиться один файл с семью запросами. Формат файла для результатов такой:
Задача 1

SELECT …

FROM …

Задача 2

SELECT …

FROM …

…



# Задача 1
Каждая строка таблицы orderdetails описывает, сколько единиц товара с соответствующим артикулом были заказаны в рамках конкретного заказа. 
Напишите запрос, который выберет из таблицы orderdetails топ-10 строк с максимальной общей стоимостью конкретного товара в рамках заказа. Для каждой строки выведите номер заказа, артикул товара и общую стоимость товара в заказе. 


# Задача 2
В предыдущей задаче вы нашли пары «номер заказа, артикул товара», для которых суммарная стоимость конкретного товара в рамках заказа была максимальной. Однако в рамках одного заказа могут быть заказаны разные товары. 
Напишите запрос, который вернёт только те заказы, итоговая стоимость которых превышает 59 000 долларов.


# Задача 3
В предыдущей задаче вы выбрали номера заказов, итоговая сумма которых превышала 59 000 долларов. Теперь нужно узнать дату, когда были сделаны эти заказы, и статусы, в которых они находятся.



# Задача 4
Теперь вы знаете, столько стоили самые дорогие заказы, когда они были сделаны и в каком статусе находятся. Пришло время узнать, кто их сделал. 



# Задача 5
В задачах 1—4 вы исследовали самые дорогие заказы, когда и кем они были сделаны. Вы начали от таблицы orderdetails и двигались к таблице customers через таблицу orders.



# Задача 6
В материалах модуля мы рассмотрели три вида оператора JOIN: INNER, LEFT и RIGHT. Однако, в языке SQL есть ещё один вид соединения таблиц — FULL JOIN. 
FULL JOIN — это ситуация, в которой значения NULL могут быть как справа, так и слева. То есть FULL JOIN собирает в одной результирующей таблице всех:

1.Сотрудников, которые обслуживали клиентов.
2.Клиентов, которые были обслужены сотрудниками.
3.Сотрудников, которые никого ещё не обслуживали.
4.Клиентов, которых никто не обслужил

СУБД MySQL не поддерживает FULL JOIN в явном виде, но вы можете его смоделировать. Подумайте, как это сделать. Напишите запрос, который реализует FULL JOIN для таблиц employees и customers и выводит имена и фамилии сотрудников (firstName и lastName) и клиентов (contactFirstName и contactLastName). 



# Задача 7
Посмотрите на таблицу employees на ER-диаграмме:


Автосвязь соединяет первичный ключ таблицы employeeNumber с её внешним ключом reportsTo и реализует отношение «подчинённый → начальник». Так, если какой-либо сотрудник напрямую подчиняется сотруднику 1002, то в поле reportsTo у него будет установлено 1002.

Напишите запрос, который вернёт таблицу вида:

    firstName       |    lastName     |    jobTitle     |     subFirstName    |   subLastName

    Diane           |    Murphy       |    President    |          Mary       |    Patterson

Где:

firstName и lastName — имя и фамилия сотрудника;
jobTitle — название должности сотрудника;
subFirstName и subLastName — имя и фамилия непосредственного подчинённого. 
При этом:

если у сотрудника несколько подчинённых, в таблице для него будет несколько строк;
если у сотрудника нет подчинённых, то поля subFirstName и subLastName должны содержать значения NULL.
